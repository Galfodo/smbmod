.include "nes.h"
.include "mmc3.h"
.include "ppulib.h"
.include "joylib.h"
.include "pause.h"
.include "timers.h"
.include "vbuff.h"
.include "score.h"

.import Mirror_PPU_CTRL, Mirror_PPU_MASK
.import HorizontalScroll, VerticalScroll
.import Sprite0HitDetectFlag
.import UpdateScreenWithBuffer
.import MoveSpritesOffscreen
.import SpriteShuffler

.import InitializeMemory  
.import JumpEngine
.import TitleScreenMode, GameMode, VictoryMode, GameOverMode

.import PseudoRandomBitReg
.import NextPseudoRandom

.import CheckTopScore
.import UpdateTopScore

.import ReadJoypads
.import SavedJoypad1Bits

.import Tick

.import SoundEngine

.import TickPause
.import PlayPause

.import __SBSS_LOAD__
.import __OAM_LOAD__

MagicWarmBootNumber = $a5

.enum Operation
	TITLE_SCREEN
	GAME
	VICTORY
	GAME_OVER
.endenum

.bss
OperMode: .res 1
OperTask: .res 1

.segment "SBSS"
WarmBootValidation: .res 1

.segment "MAIN"
.align $100
.proc Reset
	sei	;pretty standard 6502 type init here
	cld

	lda #ppu::ctrl::SPR1 & ppu::ctrl::BG0 ;init PPU control register 1 
	sta ppu::CTRL

	ldx #0
	stx mmc3::bank::SELECT ;set $C000-DFFF to second-to-last PRG bank, normal CHR mode
	stx mmc3::MIRROR ;vertical mirroring
	stx mmc3::PRG_RAM ;disable PRG_RAM
	stx mmc3::irq::DISABLE

	dex	;x = 255, reset stack pointer
	txs

:
	bit ppu::STATUS	;wait two frames, bit 7 is set on VBlank
	bpl :-
:
	bit ppu::STATUS
	bpl :-
	
	ldy #$ff	;load default cold boot pointer
	jsr CheckTopScore ;this is where we check for a warm boot
	bcs ColdBoot 
	lda WarmBootValidation	;second checkpoint, check to see if 
	cmp #MagicWarmBootNumber	;another location has a specific value
	bne ColdBoot	

	ldy #<(__SBSS_LOAD__ - 1);if passed both, load warm boot pointer
ColdBoot:
	jsr InitializeMemory	;clear memory using pointer in Y
	sta apu::DELTA_REG+1	;reset delta counter load register
	sta OperMode	;reset primary mode of operation
	lda #MagicWarmBootNumber	;set warm boot flag
	sta WarmBootValidation	
	sta PseudoRandomBitReg	;set seed for pseudorandom register

	lda #%00001111
	sta apu::MASTERCTRL_REG	;enable all sound channels except dmc

	lda #ppu::mask::DISABLE_BG_CLIP & ppu::mask::DISABLE_SPR_CLIP
	sta ppu::MASK	;turn off clipping for OAM and background

	jsr InitPPULib	
:
	jmp :-	;endless loop, need I say more?
.endproc

.proc NMI
	jsr PPULibOnNMI	
	jsr UpdateScreenWithBuffer
	lda Mirror_PPU_MASK	;copy mirror of $2001 to register
	sta ppu::MASK

	jsr SoundEngine	;play sound
	jsr ReadJoypads	;read joypads
	jsr UpdateTopScore

	lda OperMode           ;are we in victory mode?
	cmp #Operation::VICTORY  ;if so, go ahead
	beq DoPause
	cmp #Operation::GAME     ;are we in game mode?
	bne SkipPause          ;if not, leave
	lda OperTask      ;if we are in game mode, are we running game engine?
	cmp #3
	bne SkipPause          ;if not, leave

DoPause:
	jsr PauseRoutine	;handle pause
SkipPause:
	lda GamePauseStatus	;check for pause status
	lsr
	bcs :+

	jsr Tick

:
	jsr NextPseudoRandom	
	bit Sprite0HitDetectFlag	;check for flag here
	beq SkipSprite0

:
	bit ppu::STATUS	;wait for sprite 0 flag to clear, which will 
	bvc :- ;bit 6 is sprite 0 hit

	lda GamePauseStatus	;if in pause mode, do not bother with sprites at all
	lsr
	bcs Sprite0Hit

	jsr MoveSpritesOffscreen
	jsr SpriteShuffler

Sprite0Hit:
	bit ppu::STATUS	;do sprite #0 hit detection
	bvc Sprite0Hit ;bit 6 is set on sprite 0 hit

BeginCritical:
	ldy #$14	;small delay, to wait until we hit horizontal blank time
:
	dey
	bne :-

SkipSprite0:
	lda HorizontalScroll	;set scroll registers from variables
	sta ppu::SCROLL_REG
	lda VerticalScroll
	sta ppu::SCROLL_REG

CRITICAL_SIZE = .sizeof(BeginCritical) + .sizeof(SkipSprite0)
.assert <(* - CRITICAL_SIZE) + CRITICAL_SIZE < $100, error

	lda Mirror_PPU_CTRL	;load saved mirror of $2000
	pha
	sta ppu::CTRL

	lda GamePauseStatus	;if in pause mode, do not perform operation mode stuff
	lsr
	bcs SkipMainOper
	jsr OperModeExecutionTree ;otherwise do one of many, many possible subroutines

SkipMainOper:
	lda ppu::STATUS	;reset flip-flop
	pla
	ora #ppu::ctrl::ENABLE_NMI	;reactivate NMIs
	sta ppu::CTRL

	rti	;we are done until the next frame!
.endproc

.proc PauseRoutine

.proc OperModeExecutionTree
	lda OperMode     ;this is the heart of the entire program,
	jsr JumpEngine   ;most of what goes on starts here

	.word TitleScreenMode
	.word GameMode
	.word VictoryMode
	.word GameOverMode
.endproc

.proc IRQ
	rti
.endproc

.segment "VECTORS"

	.word NMI
	.word Reset
	.word IRQ

